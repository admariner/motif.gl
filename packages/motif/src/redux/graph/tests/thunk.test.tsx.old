// @ts-nocheck
import React from 'react';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import cloneDeep from 'lodash/cloneDeep';
import flatten from 'lodash/flatten';
import { render } from '@testing-library/react';
import { ToasterContainer } from 'baseui/toast';
import {
  computeEdgeSelection,
  groupEdgesWithAggregation,
  importEdgeListData,
  importJsonData,
  importNodeEdgeData,
  importSampleData,
} from '../thunk';
import {
  initialState,
  addQuery,
  processGraphResponse,
  updateStyleOption,
  overwriteEdgeSelection,
  updateLastGroupEdgeIds,
} from '../slice';
import {
  importJson,
  importNodeEdgeCsv,
  importEdgeListCsv,
} from '../processors/import';
import { fetchBegin, fetchDone, updateToast, closeModal } from '../../ui/slice';
import {
  GraphWithGroupEdge,
  SimpleEdge,
  SimpleGraphWithGroupEdge,
} from '../../../constants/sample-data';
import { RootState } from '../../investigate';
import {
  Accessors,
  Field,
  GraphData,
  GraphList,
  ImportFormat,
  JsonImport,
  Selection,
  TLoadFormat,
} from '../types';
import * as LAYOUT from '../../../constants/layout-options';
import { DEFAULT_NODE_STYLE } from '../../../constants/graph-shapes';
import {
  groupEdgesForImportation,
  groupEdgesWithConfiguration,
} from '../processors/group-edges';
import { getGraph } from '../selectors';
import { resetState } from '../../import/fileUpload/slice';
import { TFileContent } from '../../import/fileUpload';
import { numericAccessorsNodeEdge, whitespaceNodeEdge } from './constant';

const mockStore = configureStore([thunk]);
const getStore = (): RootState => {
  const graphState = cloneDeep(initialState);
  const store = {
    investigate: {
      ui: {},
      widget: {},
      graph: {
        present: graphState,
      },
    },
  };
  return store;
};

describe('thunk.test.js', () => {
  beforeEach(() => {
    render(<ToasterContainer />);
  });


  describe('importEdgeListData', () => {

    describe('computeEdgeSelection', () => {
      const simpleGraphWithGroupEdge = SimpleGraphWithGroupEdge();
      const aggregatedEdgeFields: Field[] = [
        {
          name: 'id',
          format: '',
          type: 'string',
          analyzerType: 'string',
        },
        {
          name: 'source',
          format: '',
          type: 'string',
          analyzerType: 'string',
        },
        {
          name: 'target',
          format: '',
          type: 'string',
          analyzerType: 'string',
        },
        {
          name: 'numeric',
          format: '',
          type: 'integer',
          analyzerType: 'INT',
        },
        {
          name: 'value',
          format: '',
          type: 'string',
          analyzerType: 'STRING',
        },
        {
          name: 'date',
          format: '',
          type: 'string',
          analyzerType: 'STRING',
        },

        {
          analyzerType: 'INT',
          format: '',
          name: 'min numeric',
          type: 'integer',
        },
        {
          analyzerType: 'INT',
          format: '',
          name: 'max numeric',
          type: 'integer',
        },
        {
          analyzerType: 'INT',
          format: '',
          name: 'average numeric',
          type: 'integer',
        },
        {
          analyzerType: 'INT',
          format: '',
          name: 'count numeric',
          type: 'integer',
        },
        {
          analyzerType: 'INT',
          format: '',
          name: 'sum numeric',
          type: 'integer',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'first value',
          type: 'string',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'last value',
          type: 'string',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'most_frequent value',
          type: 'string',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'first date',
          type: 'string',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'last date',
          type: 'string',
        },
        {
          analyzerType: 'STRING',
          format: '',
          name: 'most_frequent date',
          type: 'string',
        },
      ];

      Object.assign(simpleGraphWithGroupEdge.metadata.fields, {
        edges: aggregatedEdgeFields,
      });

      const importedGraphState = (): RootState => {
        const store = {
          investigate: {
            ui: {},
            widget: {},
            graph: {
              present: {
                graphFlatten: simpleGraphWithGroupEdge,
                edgeSelection: [
                  {
                    label: 'id',
                    id: 'id',
                    type: 'string',
                    selected: true,
                  },
                  {
                    label: 'source',
                    id: 'source',
                    type: 'string',
                    selected: true,
                  },
                  {
                    label: 'target',
                    id: 'target',
                    type: 'string',
                    selected: true,
                  },
                ],
              },
            },
          },
        };
        return store;
      };

      const store = mockStore(importedGraphState());

      beforeEach(() => {
        store.dispatch(computeEdgeSelection());
      });

      afterEach(() => {
        store.clearActions();
      });

      it('should append edge selection based on edge fields', () => {
        const { edgeSelection, graphFlatten } = getGraph(store.getState());
        const { edges: edgeFields } = graphFlatten.metadata.fields;

        const computedEdgeSelection = edgeFields.map((edgeField: Field) => {
          const { name, type } = edgeField;
          const existingSelection = edgeSelection.find(
            (selection: Selection) => selection.id === edgeField.name,
          );
          const isSelected: boolean = existingSelection?.selected ?? false;

          return {
            id: name,
            label: name,
            type,
            selected: isSelected,
          };
        });

        const expectedActions = [overwriteEdgeSelection(computedEdgeSelection)];

        expect(store.getActions()).toEqual(expectedActions);
      });
    });
  });
});
